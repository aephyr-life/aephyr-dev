# ──────────────────────────────────────────────────────────────────────────────
# Aephyr Dev Justfile
# - Bash mit strikten Flags
# - Zentrale DB- und Flyway-Variablen
# - Masking bei Passwort-Ausgaben
# - Interaktive PR-Erstellung
# ──────────────────────────────────────────────────────────────────────────────

set shell := ["bash", "-euo", "pipefail", "-c"]

# ── Variablen (ggf. per ENV überschreiben) ───────────────────────────────────
DB_HOST        := "{{env_var("DB_HOST", "localhost")}}"
DB_PORT        := "{{env_var("DB_PORT", "54329")}}"
DB_NAME        := "{{env_var("DB_NAME", "aephyr")}}"
DB_SUPER       := "{{env_var("DB_SUPER", "postgres")}}"

MIGRATOR_USER  := "{{env_var("FLYWAY_USER", "aephyr_migrator")}}"
MIGRATOR_PASS  := "{{env_var("FLYWAY_PASSWORD", "")}}"
APP_USER       := "{{env_var("DB_USER", "aephyr_app")}}"
APP_PASS       := "{{env_var("DB_PASSWORD", "")}}"

FLYWAY_URL     := "jdbc:postgresql://{{DB_HOST}}:{{DB_PORT}}/{{DB_NAME}}"

PG_DIR         := ".pg"
PG_DATA        := "{{PG_DIR}}/data"
PG_LOG         := "{{PG_DIR}}/postgres.log"

default:
  @just --list

# ── Build / Test / Dev ───────────────────────────────────────────────────────
build:        # builds the program
  sbt compile

clean:        # cleans the build
  sbt clean

test:         # runs the tests
  sbt test

fmt:          # formats the code
  sbt scalafmtAll

repl:         # opens a repl
  sbt console

api-run:      # starts the api server
  sbt "api-server/run"

update-lock:  # updates flake.lock
  nix flake update

reload:       # devShell neu laden
  direnv reload

gen-key:      # generates a 32-Byte Base64URL key (no padding)
  openssl rand -base64 32 | tr '+/' '-_' | tr -d '='

dependencies: # checks dependencies
  sbt ";undeclaredCompileDependencies;unusedCompileDependencies"

# ── DB: Local Postgres (initdb/pg_ctl) ───────────────────────────────────────
db-init:      # initializes the db cluster and creates DB
  mkdir -p "{{PG_DIR}}"
  if [ ! -d "{{PG_DATA}}" ]; then \
    initdb -D "{{PG_DATA}}" -U "{{DB_SUPER}}"; \
    awk '{print} END {print "host all all 127.0.0.1/32 trust"; print "host all all ::1/128 trust"}' "{{PG_DATA}}/pg_hba.conf" > "{{PG_DATA}}/pg_hba.conf.new"; \
    mv "{{PG_DATA}}/pg_hba.conf.new" "{{PG_DATA}}/pg_hba.conf"; \
  fi
  pg_ctl -D "{{PG_DATA}}" -l "{{PG_LOG}}" -o "-p {{DB_PORT}} -c listen_addresses={{DB_HOST}}" start
  sleep 1
  createdb -h "{{DB_HOST}}" -p "{{DB_PORT}}" -U "{{DB_SUPER}}" "{{DB_NAME}}" || true
  pg_ctl -D "{{PG_DATA}}" stop -m fast

db-start:     # start the db
  pg_ctl -D "{{PG_DATA}}" -l "{{PG_LOG}}" -o "-p {{DB_PORT}} -c listen_addresses={{DB_HOST}}" start
  sleep 1
  echo "Postgres on postgres://{{DB_HOST}}:{{DB_PORT}}/{{DB_NAME}} (log: {{PG_LOG}})"

db-stop:      # stop the db
  pg_ctl -D "{{PG_DATA}}" stop -m fast

db-logs:      # view db logs
  tail -f "{{PG_LOG}}"

psql:         # psql console (superuser)
  psql -h "{{DB_HOST}}" -p "{{DB_PORT}}" -U "{{DB_SUPER}}" -d "{{DB_NAME}}"

db-seed:      # seed dev users (runs as migrator)
  PGPASSWORD="{{MIGRATOR_PASS}}" psql -h "{{DB_HOST}}" -p "{{DB_PORT}}" -U "{{MIGRATOR_USER}}" -d "{{DB_NAME}}" -v ON_ERROR_STOP=1 -f modules/db-migrations/src/main/resources/db/seed/dev_users.sql

# ── DB: Bootstrap Rollen/Schemata (einmalig nach Start) ──────────────────────
db-bootstrap:
  @echo "Creating roles (passwords masked)…"
  @echo " - {{MIGRATOR_USER}} / *****"
  @echo " - {{APP_USER}} / *****"
  PGPASSWORD="" psql -h "{{DB_HOST}}" -p "{{DB_PORT}}" -U "{{DB_SUPER}}" -d "{{DB_NAME}}" -v ON_ERROR_STOP=1 -c "CREATE ROLE {{MIGRATOR_USER}} LOGIN PASSWORD '{{MIGRATOR_PASS}}';" || true
  PGPASSWORD="" psql -h "{{DB_HOST}}" -p "{{DB_PORT}}" -U "{{DB_SUPER}}" -d "{{DB_NAME}}" -v ON_ERROR_STOP=1 -c "CREATE ROLE {{APP_USER}} LOGIN PASSWORD '{{APP_PASS}}';" || true
  psql -h "{{DB_HOST}}" -p "{{DB_PORT}}" -U "{{DB_SUPER}}" -d "{{DB_NAME}}" -v ON_ERROR_STOP=1 -c "GRANT CREATE, USAGE ON SCHEMA public TO {{MIGRATOR_USER}};"
  psql -h "{{DB_HOST}}" -p "{{DB_PORT}}" -U "{{DB_SUPER}}" -d "{{DB_NAME}}" -v ON_ERROR_STOP=1 -c "CREATE SCHEMA IF NOT EXISTS events;"
  psql -h "{{DB_HOST}}" -p "{{DB_PORT}}" -U "{{DB_SUPER}}" -d "{{DB_NAME}}" -v ON_ERROR_STOP=1 -c "CREATE SCHEMA IF NOT EXISTS read;"
  psql -h "{{DB_HOST}}" -p "{{DB_PORT}}" -U "{{DB_SUPER}}" -d "{{DB_NAME}}" -v ON_ERROR_STOP=1 -c "CREATE SCHEMA IF NOT EXISTS tech;"
  psql -h "{{DB_HOST}}" -p "{{DB_PORT}}" -U "{{DB_SUPER}}" -d "{{DB_NAME}}" -v ON_ERROR_STOP=1 -c "ALTER SCHEMA events OWNER TO {{MIGRATOR_USER}};"
  psql -h "{{DB_HOST}}" -p "{{DB_PORT}}" -U "{{DB_SUPER}}" -d "{{DB_NAME}}" -v ON_ERROR_STOP=1 -c "ALTER SCHEMA read  OWNER TO {{MIGRATOR_USER}};"
  psql -h "{{DB_HOST}}" -p "{{DB_PORT}}" -U "{{DB_SUPER}}" -d "{{DB_NAME}}" -v ON_ERROR_STOP=1 -c "ALTER SCHEMA tech  OWNER TO {{MIGRATOR_USER}};"
  psql -h "{{DB_HOST}}" -p "{{DB_PORT}}" -U "{{DB_SUPER}}" -d "{{DB_NAME}}" -v ON_ERROR_STOP=1 -c "ALTER ROLE {{APP_USER}} SET search_path = '';"
  psql -h "{{DB_HOST}}" -p "{{DB_PORT}}" -U "{{DB_SUPER}}" -d "{{DB_NAME}}" -v ON_ERROR_STOP=1 -c "REVOKE USAGE ON SCHEMA public FROM {{APP_USER}};"

# ── Flyway ───────────────────────────────────────────────────────────────────
migrate:      # migrates the db (runs the Scala main in db-migrations)
  FLYWAY_URL="{{FLYWAY_URL}}" \
  FLYWAY_USER="{{MIGRATOR_USER}}" \
  FLYWAY_PASSWORD="{{MIGRATOR_PASS}}" \
  sbt "db-migrations/run"

# ── Git / PR ─────────────────────────────────────────────────────────────────
pr:           # create draft PR interactively (branch + push + PR)
  @echo "Select branch type:"
  @PS3="> "; select prefix in feature fix chore test refactor docs; do \
    if [[ -n "$prefix" ]]; then \
      read -r -p "Enter branch name (kebab-case): " name; \
      git switch -c "$prefix/$name"; \
      git push -u origin "$prefix/$name"; \
      gh pr create --fill --base main --head "$prefix/$name" --draft; \
      break; \
    else \
      echo "Invalid choice"; \
    fi \
  done