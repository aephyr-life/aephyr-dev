<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>WebAuthn Test Page</title>
    <style>
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; line-height: 1.4; margin: 2rem; }
        pre { background: #111; color: #ddd; padding: 1rem; border-radius: 8px; overflow:auto; }
        .row { display:flex; gap:.5rem; align-items:center; margin:.5rem 0 1rem; flex-wrap: wrap; }
        button { padding:.5rem .8rem; font-size: 1rem; cursor:pointer; }
        .pill { display:inline-block; padding:.15rem .5rem; border-radius:999px; background:#eee; color:#333; font-size:.85rem; }
    </style>
</head>
<body>
<h1>WebAuthn Test <span id="status" class="pill">no token</span></h1>

<div class="row">
    <button onclick="beginRegistration()">Begin Registration</button>
    <button onclick="beginAuthentication()">Begin Authentication</button>
    <button onclick="callMe()">Call /api/me</button>
</div>

<pre id="log"></pre>

<script>
    const API_BASE = "https://dev.aephyr.life/api/webauthn";
    const API_ME   = "https://dev.aephyr.life/api/me";

    const state = { token: null };

    function setToken(t) {
      state.token = t || null;
      document.getElementById('status').textContent = state.token ? 'token set' : 'no token';
    }

    function log(...args) {
      const line = args.map(x => (typeof x === 'object' ? JSON.stringify(x) : String(x))).join(' ');
      document.getElementById('log').textContent += line + "\n";
      console.log(...args);
    }

    // === base64url helpers ===
    function bufToB64Url(buf) {
      const bytes = new Uint8Array(buf);
      let bin = "";
      for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
      return btoa(bin).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/,"");
    }

    function b64UrlToBytes(b64url) {
      let b64 = b64url.replace(/-/g, "+").replace(/_/g, "/");
      while (b64.length % 4) b64 += "=";
      const bin = atob(b64);
      const bytes = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
      return bytes;
    }

    function b64UrlToArrayBuffer(b64url) {
    if (b64url == null || b64url === "") return new ArrayBuffer(0);
    let b64 = b64url.replace(/-/g, "+").replace(/_/g, "/");
    while (b64.length % 4) b64 += "=";
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
    return bytes.buffer;
  }

  function arrayBufferByteLen(x) {
    if (x instanceof ArrayBuffer) return x.byteLength;
    if (ArrayBuffer.isView(x)) return x.byteLength;
    return -1;
  }

    function sanitizeGetOptions(publicKey) {
      // rpId must be a registrable suffix of current origin
      const host = location.hostname; // e.g., "dev.aephyr.life"
      if (publicKey.rpId) {
        const ok = (host === publicKey.rpId) || host.endsWith("." + publicKey.rpId);
        if (!ok) {
          throw new Error(`rpId mismatch: options.rpId="${publicKey.rpId}" vs page.host="${host}". Serve this page from https://${publicKey.rpId}/ or adjust your server RP ID.`);
        }
      }
      // bytes
      publicKey.challenge = b64UrlToArrayBuffer(publicKey.challenge);

      if (typeof publicKey.timeout === "string") {
        const n = parseInt(publicKey.timeout, 10);
        if (!Number.isNaN(n)) publicKey.timeout = n;
      }

      if (publicKey.userVerification) {
        publicKey.userVerification = String(publicKey.userVerification).toLowerCase(); // "required" | "preferred" | "discouraged"
      }

      if (Array.isArray(publicKey.allowCredentials)) {
        publicKey.allowCredentials = publicKey.allowCredentials
          .map(c => ({
            type: "public-key", // normalize (spec requires "public-key")
            id: (c.id instanceof ArrayBuffer || ArrayBuffer.isView(c.id))
                  ? (ArrayBuffer.isView(c.id) ? c.id.buffer : c.id)
                  : b64UrlToArrayBuffer(c.id),
            transports: Array.isArray(c.transports)
              ? c.transports.filter(t => ["usb","nfc","ble","internal","hybrid","cable"].includes(t))
              : undefined
          }))
          .filter(c => arrayBufferByteLen(c.id) > 0); // drop empty ids
        if (publicKey.allowCredentials.length === 0) {
          delete publicKey.allowCredentials; // empty array can trip some user agents
        }
      }

      // Optional: log sizes, not raw bytes
      const debug = {
        ...publicKey,
        challenge: `(bytes ${arrayBufferByteLen(publicKey.challenge)})`,
        allowCredentials: publicKey.allowCredentials?.map(c => ({
          type: c.type,
          id: `(bytes ${arrayBufferByteLen(c.id)})`,
          transports: c.transports
        }))
      };
      log("Sanitized get() options:", debug);
      return publicKey;
    }

    async function beginRegistration() {
      try {
        // 1) options (POST, no body, no Content-Type)
        const resp = await fetch(`${API_BASE}/registration/options`, { method: "POST" });
        const { tx, publicKey } = await resp.json();
        log("BeginReg options:", { tx, publicKey });

        // 2) decode
        publicKey.challenge = b64UrlToBytes(publicKey.challenge);
        publicKey.user.id   = b64UrlToBytes(publicKey.user.id);
        if (publicKey.excludeCredentials) {
          publicKey.excludeCredentials = publicKey.excludeCredentials.map(c => ({ ...c, id: b64UrlToBytes(c.id) }));
        }

        // 3) create credential
        const cred = await navigator.credentials.create({ publicKey });
        log("Created credential:", cred);

        // 4) payload
        const payload = cred.toJSON ? cred.toJSON() : {
          id: cred.id,
          rawId: bufToB64Url(cred.rawId),
          type: cred.type,
          response: {
            clientDataJSON:    bufToB64Url(cred.response.clientDataJSON),
            attestationObject: bufToB64Url(cred.response.attestationObject)
          },
          clientExtensionResults: cred.getClientExtensionResults?.() ?? {}
        };

        // 5) verify -> token
        const verify = await fetch(`${API_BASE}/registration/${tx}/verify`, {
          method: "POST",
          headers: {"Content-Type": "application/json"},
          body: JSON.stringify(payload)
        });

        const body = await verify.json().catch(async () => ({ raw: await verify.text() }));
        log("FinishReg status:", verify.status, body);

        const token = body?.accessToken;
        if (token) {
          setToken(token);
          await callMe(); // call /me immediately
        } else {
          log("❌ No accessToken in response.");
        }
      } catch (e) {
        log("❌ beginRegistration error:", e?.message || e);
      }
    }

    async function beginAuthentication() {
      try {
        const resp = await fetch(`${API_BASE}/authentication/options`, { method: "POST" });
        const { tx, publicKey } = await resp.json();
        log("BeginAuth options (raw):", { tx, publicKey });

        // sanitize/normalize before calling WebAuthn
        sanitizeGetOptions(publicKey);

        // get assertion
        const assertion = await navigator.credentials.get({ publicKey });
        log("Got assertion:", assertion);

        const payload = assertion.toJSON ? assertion.toJSON() : {
          id: assertion.id,
          rawId: bufToB64Url(assertion.rawId),
          type: assertion.type,
          response: {
            clientDataJSON:    bufToB64Url(assertion.response.clientDataJSON),
            authenticatorData: bufToB64Url(assertion.response.authenticatorData),
            signature:         bufToB64Url(assertion.response.signature),
            userHandle:        assertion.response.userHandle ? bufToB64Url(assertion.response.userHandle) : null
          },
          clientExtensionResults: assertion.getClientExtensionResults?.() ?? {}
        };

        const verify = await fetch(`${API_BASE}/authentication/${tx}/verify`, {
          method: "POST",
          headers: {"Content-Type": "application/json"},
          body: JSON.stringify(payload)
        });

        const text = await verify.text();
        let body;
        try { body = JSON.parse(text); } catch { body = { raw: text }; }
        log("FinishAuth status:", verify.status, body);

        const token = body?.accessToken;
        if (token) { setToken(token); await callMe(); }
        else log("❌ No accessToken in auth response.");
      } catch (e) {
        log("❌ beginAuthentication error:", e?.name || "Error", e?.message || e);
      }
    }

    async function callMe() {
      try {
        if (!state.token) {
          log("ℹ️ No token set. Run registration/auth first.");
          return;
        }
        const r = await fetch(API_ME, {
          headers: {
            "Authorization": `Bearer ${state.token}`,
            "Accept": "application/json"
          }
        });

        const text = await r.text();
        log(`GET /api/me status: ${r.status}`, text);
      } catch (e) {
        log("❌ /api/me error:", e?.message || e);
      }
    }
</script>
</body>
</html>
